---
layout: default
---

# Installation

```sh
npm i @smallhillcz/routesjs
```

# Motivation

 - Frontend should not decided what resources are available to current user, instead API should tell frontend what is available.
 - Permissions of users on documents should be abstracted from controllers
 - Documents states should be, apart from standard CRUD operations, controlled by predefined workflows (i.e. draft -> pending approval -> published ).
 - Frontend should not (note: contradicts REST?!) know which state will document end in, just which action is available. For example blog writer should know that `publish` action is available for the user and document, but shouldn't know, that the document would go `pending approval`. This is driven by these thoughts:
   - Frontend should not need to know the business logic of the workflow.
   - User should care only about their actions, not where the document goes next, i.e. separation of concerns.
   - When workflow changes, nothing should change for current action, if it is not the subject of change itself.
 - Despite workflow integrations API should follow REST guidelines.
 - API should be self documented, changes in API should automatically propagate to docs

# Solution

### HATEOAS HAL Support
 - [x] Root endpoint contains _links JSON object with global resources as properties
 - [x] Each document is appended with _links JSON object with child resources as properties
 - [x] Each `_links` object contains `self` resource which represents current document
 - [x] Each `_links` property contains `href` property, which contains URL
 - [ ] Each `_links` property contains `methods` object which shows possible methods as keys and their boolean availability as values
 - [x] Each document is appended with `_actions` object with possible workflow state changing actions
 - [x] Each `_actions` property contains `href` property, which contains URL where POST request is issued to traverse document state
 - [x] For each `_links` item, availability for current user and document is shown.

### Route and Document Level Access Control
 - [x] Route level permissions authorize user to open api endpoint
 - [x] Permissions define filters
 
### Built-in document workflow status support
 - [ ] Document workflow is defined for each 

### OpenAPI documentation
 - [x] OpenAPI documentation is autogenerated from defined routes and provided descriptions.



## Examples

 - [Usage](#usage)
    - Import Routes and bind to Express app
    - Making a child router
    - Binding Routes child to Express router
    - Binding Routes child to Express app
    - Using Express router alongside Routes
 - [Routes](#routes)
    - Simplest route definition
    - Handle the route with Express middleware
    - Limit route to be listed only under certain docs (uses [mongo-parse](https://www.npmjs.com/package/mongo-parse) for matching)
 - [RoutesLinks](#routeslinks)
    - Create root API endpoint
    - Add the route to `_links` and `_actions` of documents
 - [RoutesACL](#routesacl)
    - Define user roles and permissions
    - Set up RoutesACL
    - Limit route to users with certain permission (also limits route allowed indicator in `_links`)
 - [RoutesPluginMongoose](#routespluginmongoose)
    - Plug the plugin to Mongoose
    - Filter mongoose docs according to permissions

### Import Routes and bind to Express app

routes.js
```js
const { Routes } = require("@smallhillcz/routesjs");
const routes = new Routes();

// your routes
routes.get("posts","/posts").handle( (req,res,next) => { ... } );
routes.get("posts","/posts/comments").handle( (req,res,next) => { ... } );

module.exports = routes;
```

app.js
```js
// load express app
const express = require("express");
const app = express();

// bind Routes
app.use("/", require("./routes");

app.listen(...) // create server as per express documentation
```

### Making a child router
child.js
```js
const { Routes } = require("@smallhillcz/routesjs");
const routes = new Routes();

// your child routes
routes.get("posts","/").handle(...);
routes.post("posts","/").handle(...);

module.exports = routes;
```

main.js
```js
const { Routes } = require("@smallhillcz/routesjs");
const routes = new Routes();

routes.child("/posts",require("./child"));
```

### Binding Routes child to Express router
```js
const router = express.Router();

router.use("/posts", require("./child").router);
```

### Binding Routes child to Express app
```js
const app = express();

app.use("/posts", require("./child").router);
```

### Using Express router alongside Routes
```js
routes.router.get(...);
routes.router.post(...);
routes.router.use(...);
```

## Routes

### Simplest route definition

```javascript
routes.get("posts","/posts");
```

Provide name of the route and url.

### Handle the route with Express middleware
```javascript
routes.get("posts","/posts").handle( async (req,res,next) => {
  const posts = await Post.find();
  res.json(posts);
});
```

### Limit route to be listed only under certain docs (uses [mongo-parse](https://www.npmjs.com/package/mongo-parse) fot matching)
```js
routes.post("post:publish", "/posts/:post/publish", { query: { status: "draft" } }).handle(async (req,res) => {
  await Post.findOneAndUpdate({ id:req.params.event }, { status: "public" });
  res.sendStatus(200);
});
```

## RoutesLinks

### Create root API endpoint

Either use routes way including permission to read api:
```js
routes.get(null, "/", { permission: "api:read" }).handle((req,res) => {
  res.json({
    name: "My awesome API",
    _links: RoutesLinks.root(req)
  });
});
```
or use Express router:
```js
routes.router.get("/", (req,res) => {
  res.json({
    name: "My awesome API",
    _links: RoutesLinks.root(req)
  });
});
```

The output of `GET /` will look like this:
```js
{
  name: "My awesome API",
  _links: {
    "self": { href: "/", allowed: { GET: true } }, 
    "posts:self": { href: "/posts", allowed: { GET: true, POST: true } }, 
    "post:self": { href: "/posts/:post", templated: true, allowed: { GET: true } }, 
    "post:comments": { href: "/posts/:post/comments", templated: true, allowed: { GET: true } }
  }
}
```

### Add the route to `_links` and `_actions` of documents
```javascript

// define some routes to be added
routes.get("post","/posts/:post");
routes.patch("post","/posts/:post");
routes.get("post:comments","/posts/:post/comments");
routes.action("post:publish","/posts/:post/publish")

// route to list posts
routes.get("posts","/posts").handle( async (req,res,next) => {
  
  // get posts
  const posts = await Post.find().lean(); // mongoose objects cannot be modified, therefore .lean()
  
  // append links
  req.routes.links(posts,"post"); // "post" defines which routes will be used, here staring with "post:"
  
  // return posts to client
  res.json(posts);
});
```

The output of `GET /posts` will look like this:
```js
[
 {
  id: 1,
  name: "Post name",
  _links: {
   "self": { href: "/posts/1", allowed: { GET: true, PATCH: true } }, 
   "comments": { href: "/posts/1/comments", allowed: { GET: true } }
  },
  _actions: {
   "publish": { href: "/posts/1", allowed: true }
  },
  ...
]  
```


## RoutesACL

### Define user roles and permissions
#### Define simple allow
```js

const permissions = {
  "posts:list": { admin: true, editor: true, guest: true },
  "posts:edit": { admin: true, editor: true }
};
```
TIP! Use preset vars for better readability:
```js
const admin = true, editor = true, guest = true;

const permissions = {
    "posts:list": { admin, editor, guest },  
    "posts:list": { admin, editor }
  }
};
```
#### Define filter allow - as a route guard works same as `true`, for `_links` and RoutesPluginsMongoose also filters documents
```js
const permissions = {
  ...
  "posts:publish": { admin: true, editor: true, assistantEditor: { postType: "unimportant" } }
  ...
};
```

#### Define condition or filter based on function of `req`
```js
const permissions = {
  ...
  "posts:edit": { admin: true, author: req => ({ author: req.user.id }) }
  ...
};
```

### Set up RoutesACL
```js
Routes.setACL({
  // permissions from previous part
  permissions: require("./permissions"),
  // function to get user roles from req
  userRoles: req => req.user ? req.user.roles || [] : [],
  // user role assigned to every request
  defaultRole: "guest",
  
  // log route access to console
  logConsole: true,
  // how the log should look like
  logString: event => `ACL ${event.result ? "OK" : "XX"} | permission: ${event.permission}, user: ${event.req.user ? event.req.user._id : "-"}, roles: ${event.req.user ? event.req.user.roles.join(",") : "-"}, ip: ${event.req.headers['x-forwarded-for'] || event.req.connection.remoteAddress}`
});
```

### Limit route to users with certain permission (also limits route allowed indicator in `_links`)
```js
routes.post("events", "/events", { permission: "events:list" }).handle(async (req,res) => {
  const events = await Event.find();
  res.json(events);
});
```

## RoutesPluginsMongoose

### Plug the plugin to Mongoose

```js
const { RoutesPluginsMongoose } = require("@smallhillcz/routesjs/lib/plugins/mongoose");

mongoose.plugin(RoutesPluginsMongoose);
```

### Filter mongoose docs according to permissions

```javascript
routes.get("my-events","/my/events").handle( async (req,res,next) => {
  
  const events = await Event.find().filterByPermission("my-events:list", req); // filter only my events
  
  res.json(events);
});
```

# Known limits

### It is not possible to guard against doc, instead returns 404

In the following code the constant `events` is going to be `null` as if event was not found. It is not possible to distinguish non existent document from the case when document would be found but is not accessible due to permissions.

```javascript
routes.get("my-event","/my/events/:event").handle( async (req,res,next) => {
  
  // get event from database
  const event = await Event.findOne().filterByPermission("my-events:read", req); // filter only my events
  
  // event not found
  if(!event) return res.sendStatus(404);
  
  // reurn event
  res.json(event);
});
```
